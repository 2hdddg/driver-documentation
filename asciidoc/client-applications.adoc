[[driver-client-applications]]
= Client applications

[abstract]
--
This section describes how to manage database connections within an application.
--


[[driver-driver-object]]
== The Driver object

Neo4j client applications require a Driver object which, from a data access perspective, forms the backbone of the application.
It is through this object that all Neo4j interaction is carried out, and it should therefore be made available to all parts of the application that require data access.
In languages where <<term-thread-safety, thread safety>> is an issue, this Driver object can be considered thread-safe.


[TIP]
.A note on lifecycle
--
Applications will typically construct a Driver object on startup and destroy it on exit.
Destroying a Driver object will immediately shut down any connections previously opened via that driver, by closing the associated connection pool.
This will have the consequence of rolling back any open transactions, and closing any unconsumed results.
--

To construct a driver instance, a <<driver-connection-uris, connection URI>> and <<driver-authentication, authentication information>> must be supplied.
Additional configuration details can be supplied if required.
All of these details are immutable for the lifetime of the Driver.
Therefore, if multiple configurations are required (such as when working with multiple database users) then multiple Driver instances must be used.


[.tabbed-example]
.The driver lifecycle
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=driver-lifecycle]
----
======


[.include-with-java]
======
[source, java]
----
include::{java-examples}/DriverLifecycleExample.java[tags=driver-lifecycle]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=driver-lifecycle]
----
======

// [.include-with-python]
// ======
// [source, python]
// ----
// include::{python-examples}/driver_lifecycle_example.py[tags=driver-lifecycle]
// ----
// ======
====


[[driver-connection-uris]]
== Connection URIs

Connection URIs are typically formed according to the following pattern:

----
neo4j://<HOST>:<PORT>[?<ROUTING_CONTEXT>]
----

This targets a routed Neo4j service that may be fulfilled by either a cluster or a single instance.
The HOST and PORT values contain a logical hostname and port number targeting the entry point to the Neo4j service (e.g. neo4j://graph.example.com:7687).
In a clustered environment, this will resolve to one of more of the core members; for standalone installations, this will simply point to that server address.
The ROUTING_CONTEXT option allows for customization of the routing table and is discussed in more detail in <<driver-routing-context>>.

An alternative URI form, using the bolt URI scheme (e.g. `bolt://graph.example.com:7687`), can be used when a single point-to-point connection is required.
This variant is useful for the subset client applications (such as admin tooling) that need to be aware of individual servers, as opposed to those which require a highly available database service.

----
bolt://<HOST>:<PORT>
----

=== Initial address resolution

The address provided in a `neo4j:// URI` is used for initial and fallback communication only.
This communication occurs to bootstrap the initial routing table, through which all subsequent communication is carried out.
Fallback occurs when the driver is unable to contact any of the addresses held in the routing table, and the initial address is once again reused to bootstrap the system.

Several options are available for providing this initial logical to physical host resolution.
These include regular DNS, custom middleware such as a load balancer, and the Driver object _resolver function_.

==== DNS resolution

DNS resolution is the default, and always-available option.
As it is possible to configure DNS to resolve a single host name down to multiple IP addresses, this can be used to expose all core server IP addresses under a single host name.

image::dns-resolution.png[title="DNS resolution", role="middle"]

==== Custom middleware

Middleware, such as a load balancer, can be used to group the core servers under a single public address.

image::custom-middleware.png[title="Custom middleware"]

[[driver-resolver-function]]
==== Resolver function

Neo4j drivers also present an address resolution intercept hook called the resolver function.
This takes the form of a callback function that accepts a single input address and yields or returns multiple output addresses.
The function may hard code the output addresses or may draw them from another configuration source, as required.

image::resolver-function.png[title="Resolver function"]

The example below shows how to expand a single address into multiple (hard coded) output addresses:

[.tabbed-example]
.Custom Address Resolver
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=config-custom-resolver]
----
======

[.include-with-java]
======
[source, java]
----
include::{java-examples}/ConfigCustomResolverExample.java[tags=config-custom-resolver]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=config-custom-resolver]
----
======

// [.include-with-python]
// ======
// [source, python]
// ----
// include::{python-examples}/custom_resolver_example.py[tags=custom-resolver]
// ----
// ======
====

=== Routing table

The routing table is the glue between the driver connectivity layer and the database surface.
This table contains a list of server addresses, grouped as readers and writers, and is refreshed automatically by the driver as required.

The driver does not expose any API to work directly with the routing table, but it can sometimes be useful to explore when troubleshooting a system.

[[driver-routing-context]]
=== Routing context

A routing context can be included as the query part of a `neo4j:// URI`. Routing contexts are defined by means of server policies and allow customisation of the contents of the routing table.

.Configure a routing driver with routing context
====
This example will assume that Neo4j has been configured for server policies as described in <<operations-manual#multi-dc-load-balancing, Neo4j Operations Manual -> Load balancing for multi-data center systems>>.
In particular, a server policy called `europe` has been defined.
Additionally, we have a server `neo01.graph.example.com` to which we wish to direct the driver.

This URI will use the server policy `europe`:

`bolt+routing://neo01.graph.example.com?policy=europe`
====

[NOTE]
.Server-side configuration to enable Routing drivers with routing context
====
A prerequisite for using a Routing driver with routing context is that the Neo4j database is operated on a <<operations-manual#clustering, Causal Cluster>> with the <<operations-manual#multi-dc, Multi-data center licensing option>> enabled.
Additionally, the routing contexts must be defined within the cluster as routing _policies_.
For details on how to configure multi-data center routing policies for a Causal Cluster, please refer to <<operations-manual#multi-dc-load-balancing, Operations Manual -> Causal Clustering>>.
====




[[driver-authentication]]
== Authentication

Authentication details are provided as an auth token which contains the user names, passwords or other credentials required to access the database.
Neo4j supports multiple authentication standards but uses basic authentication by default.


[[driver-authentication-basic]]
=== Basic authentication

The basic authentication scheme is backed by a password file stored within the server and requires applications to provide a user name and password.
For this, use the basic auth helper:

[.tabbed-example]
.Basic authentication
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=basic-auth]
----
======

[.include-with-java]
======
[source, java]
----
include::{java-examples}/BasicAuthExample.java[tags=basic-auth]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=basic-auth]
----
======

// [.include-with-python]
// ======
// [source, python]
// ----
// include::{python-examples}/auth_example.py[tags=basic-auth]
// ----
// ======
====

[NOTE]
--
The basic authentication scheme can also be used to authenticate against an LDAP server.
--

=== Kerberos authentication

The Kerberos authentication scheme provides a simple way to create a Kerberos authentication token with a base64 encoded server authentication ticket.
The best way to create a Kerberos authentication token is shown below:

[.tabbed-example]
.Kerberos authentication
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=kerberos-auth]
----
======

[.include-with-java]
======
[source, java]
----
include::{java-examples}/KerberosAuthExample.java[tags=kerberos-auth]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=kerberos-auth]
----
======

// [.include-with-python]
// ======
// [source, python]
// ----
// include::{python-examples}/kerberos_auth_example.py[tags=kerberos-auth]
// ----
// ======
====

[NOTE]
--
The Kerberos authentication token can only be understood by the server if the server has the link:{kerberos-add-on-base-uri}[Kerberos Add-on] installed.
--


[[driver-authentication-custom]]
=== Custom authentication

For advanced deployments, where a custom security provider has been built, the custom authentication helper can be used.

[.tabbed-example]
.Custom authentication
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=custom-auth]
----
======

[.include-with-java]
======
[source, java]
----
include::{java-examples}/CustomAuthExample.java[tags=custom-auth]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=custom-auth]
----
======

// [.include-with-python]
// ======
// [source, python]
// ----
// include::{python-examples}/custom_auth_example.py[tags=custom-auth]
// ----
// ======
====


[[driver-security]]
== Security


[CAUTION]
There are significant changes to security settings in Neo4j 4.0. Please read this (and/or consult the migration guide) before upgrading from a previous version.

Starting with Neo4j 4.0, client-server communication uses only *unencrypted local* connections by default.
This is a change from previous versions, which switched on encryption by default, but generated a self-signed certificate out of the box.

When a full certificate is installed, and encryption is enabled on the driver, full certificate checks are carried out (refer to <<operations-manual#ssl-framework, Operations Manual -> SSL framework >>).
Full certificates provide better overall security than self-signed certificates as they include a complete chain of trust back to a root certificate authority.

[NOTE]
https://neo4j.com/aura/[Neo4j Aura] is a secure hosted service backed by full certificates signed by a root certificate authority.
To connect to Neo4j Aura, driver users must enable encryption and the complete set of certificate checks (the latter of which are enabled by default).

.Default settings
[options="header"]
|===
| Setting | Neo4j 4.x | Neo4j 3.x (Drivers 1.x)
| Bundled certificate | none | auto-generated, self-signed
| Driver encryption   | off  | on
| Bolt interface      | localhost |localhost
| Certificate expiry check  | on  |on
| Certificate CA check  | on  | off
| Certificate hostname check  | on  | off
|===


[[driver-configuration]]
== Configuration

`ConnectionAcquisitionTimeout`::

The maximum amount of time a session will wait when requesting a connection from the connection pool.
For connection pools where all connections are currently being used and the `MaxConnectionPoolSize` limit has been reached, a session will wait this duration for a connection to be made available.

Since the process of acquiring a connection may involve creating a new connection, ensure that the value of this configuration is higher than the configured `ConnectionTimeout`.
Setting a low value will allow for transactions to “fail fast” when all connections in the pool have been acquired by other transactions.
Setting a higher value will result in these transactions being queued, increasing the chances of eventually acquiring a connection at the cost of longer time to receive feedback on failure.
Finding an optimal value may require an element of experimentation, taking into consideration the expected levels of parallelism within your application as well as the `MaxConnectionPoolSize.
(Default: 60 seconds)

`ConnectionTimeout`::

The maximum amount of time to wait for a TCP connection to be established.
Connections are only created when a session requires one unless there is an available connection in the connection pool.
The driver maintains a pool of open connections which can be loaned to a session when one is available.
If a connection is not available, then an attempt to create a new connection (provided the `MaxConnectionPoolSize` limit has not been reached) is made with this configuration option, providing the maximum amount of time to wait for the connection to be established.

In environments with high latency and high occurences of connection timeouts it is recommended to configure a higher value.
For lower latency environments and quicker feedback on potential network issues configure with a lower value.
(Default: 30 seconds)

`CustomResolver`::

Specify a custom server address resolver used by the routing driver to resolve the initial address used to create the driver. See <<driver-resolver-function>> for more details.

`Encryption`::

Set whether the connections to the server uses encrypted connections.
(Default: None)

`MaxConnectionLifetime`::

The maximum duration a connection can exist before being removed from the pool.
The check on the connection’s lifetime happens when a session requires a connection.
If the available connection’s lifetime is over this limit it is closed and a new connection is created, added to the pool and returned to the requesting session.
Changing this configuration value would be useful in environments where users don’t have full control over the network environment and wish to proactively ensure all connections are ready.

Setting this option to a low value will cause a high connection churn rate, and can result in a performance drop.
It is recommended to pick a value smaller than the maximum lifetime exposed by the surrounding system infrastructure (such as operating system, router, load balancer, proxy and firewall).
Negative values result in lifetime not being checked.
(Default: 1 hour)

`MaxConnectionPoolSize`::

This setting defines the maximum total number of connections allowed, per host (i.e. cluster nodes), to be managed by the connection pool.
In other words, for a direct driver using the `bolt://` scheme, this sets the maximum number of connections towards a single database server.
For a driver connected to a cluster using the `neo4j://` scheme, this sets the maximum amount of connections per cluster member.
If a session or transaction tries to acquire a connection at a time when the pool size is at its full capacity, it must wait until a free connection is available in the pool or the request to acquire a new connection times out.
The connection acquiring timeout is configured via `ConnectionAcquisitionTimeout`.

[[driver-configuration-encryption]]
=== Encryption

TLS encryption is enabled for all connections by default.
This can be disabled through configuration as follows:

[.tabbed-example]
.Unencrypted
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=config-unencrypted]
----
======

[.include-with-go]
======
[source, go]
----
include::{go-examples}/examples_test.go[tags=config-unencrypted]
----
======

[.include-with-java]
======
[source, java]
----
include::{java-examples}/ConfigUnencryptedExample.java[tags=config-unencrypted]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=config-unencrypted]
----
======

[.include-with-python]
======
[source, python]
----
include::{python-examples}/config_unencrypted_example.py[tags=config-unencrypted]
----
======
====

The server can be modified to require encryption for all connections.
Please see the <<operations-manual#connectors, Operations Manual -> Configure Neo4j connectors>> for more information.

An attempt to connect to a server using an encryption setting not allowed by that server will result in a <<driver-service-unavailable, _Service unavailable_>> status.


[[driver-configuration-trust]]
=== Trust

During a TLS handshake, the server provides a certificate to the client application.
The application can choose to accept or reject this certificate based on one of the following trust strategies:

.Trust strategies
[options="header"]
|===
| Trust strategy                        | Description
| `TRUST_ALL_CERTIFICATES` (default)    | Accept any certificate provided by the server, regardless of CA chain.
| `TRUST_CUSTOM_CA_SIGNED_CERTIFICATES` | Accept any certificate that can be verified against a custom CA.
| `TRUST_SYSTEM_CA_SIGNED_CERTIFICATES` | Accept any certificate that can be verified against the system store.
|===

https://en.wikipedia.org/wiki/Server_Name_Indication[Server Name Indication (SNI)] is enabled by default, allowing proxy middleware to route encrypted Bolt connections to the correct backend server.

[.tabbed-example]
.Trust
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=config-trust]
----
======

[.include-with-go]
======
[source, go]
----
include::{go-examples}/examples_test.go[tags=config-trust]
----
======

[.include-with-java]
======
[source, java]
----
include::{java-examples}/ConfigTrustExample.java[tags=config-trust]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=config-trust]
----
======

[.include-with-python]
======
[source, python]
----
include::{python-examples}/config_trust_example.py[tags=config-trust]
----
======
====


[[driver-config-connection-pool-management]]
=== Connection pool management

The driver maintains a pool of connections.
The pooled connections are reused by sessions and transactions to avoid the overhead added by establishing new connections for every query.
The connection pool always starts up empty.
New connections are created on demand by sessions and transactions.
When a session or a transaction is done with its execution, the connection will be returned to the pool to be reused.

Application users can tune connection pool settings to configure the driver for different use cases based on client performance requirements and database resource consumption limits.

Detailed descriptions of connection pool settings available via driver configuration are listed below:

`MaxConnectionLifetime`::
Pooled connections older than this threshold will be closed and removed from the pool.
The actual removal happens during connection acquisition so that the new session returned is never backed by an old connection.
Setting this option to a low value will cause a high connection churn, and can result in a performance drop.
It is recommended to pick a value smaller than the maximum lifetime exposed by the surrounding system infrastructure (such as operating system, router, load balancer, proxy and firewall).
Negative values result in lifetime not being checked.
+
Default value: 1h.

`MaxConnectionPoolSize`::
This setting defines the maximum total number of connections allowed, per host, to be managed by the connection pool.
In other words, for a direct driver, this sets the maximum number of connections towards a single database server.
For a routing driver this sets the maximum amount of connections per cluster member.
If a session or transaction tries to acquire a connection at a time when the pool size is at its full capacity, it must wait until a free connection is available in the pool or the request to acquire a new connection times out.
The connection acquiring timeout is configured via `ConnectionAcquisitionTimeout`.
+
Default value: This is different for different drivers, but is a number in the order of 100.

`ConnectionAcquisitionTimeout`::
This setting limits the amount of time a session or transaction can spend waiting for a free connection to appear in the pool before throwing an exception.
The exception thrown in this case is `ClientException`.
Timeout only applies when connection pool is at its max capacity.
+
Default value: 1m.


[.tabbed-example]
.Connection pool management
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=config-connection-pool]
----
======

[.include-with-go]
======
[source, go]
----
include::{go-examples}/examples_test.go[tags=config-connection-pool]
----
======

[.include-with-java]
======
[source, java]
----
include::{java-examples}/ConfigConnectionPoolExample.java[tags=config-connection-pool]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=config-connection-pool]
----
======

[.include-with-python]
======
[source, python]
----
include::{python-examples}/config_connection_pool_example.py[tags=config-connection-pool]
----
======
====


[[driver-configuration-connection-timeout]]
=== Connection timeout

To configure the maximum time allowed to establish a connection, pass a duration value to the driver configuration.
For example:

[.tabbed-example]
.Connection timeout
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=config-connection-timeout]
----
======

[.include-with-go]
======
[source, go]
----
include::{go-examples}/examples_test.go[tags=config-connection-timeout]
----
======

[.include-with-java]
======
[source, java]
----
include::{java-examples}/ConfigConnectionTimeoutExample.java[tags=config-connection-timeout]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=config-connection-timeout]
----
======

[.include-with-python]
======
[source, python]
----
include::{python-examples}/config_connection_timeout_example.py[tags=config-connection-timeout]
----
======
====


[[driver-configuration-max-retry-time]]
=== Max retry time

To configure retry behavior, supply a value for the maximum time in which to keep attempting retries of transaction functions.
For example:

[.tabbed-example]
.Max retry time
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=config-max-retry-time]
----
======

[.include-with-go]
======
[source, go]
----
include::{go-examples}/examples_test.go[tags=config-max-retry-time]
----
======

[.include-with-java]
======
[source, java]
----
include::{java-examples}/ConfigMaxRetryTimeExample.java[tags=config-max-retry-time]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=config-max-retry-time]
----
======

[.include-with-python]
======
[source, python]
----
include::{python-examples}/config_max_retry_time_example.py[tags=config-max-retry-time]
----
======
====

Note that the time specified here does not take into account the running time of the unit of work itself, merely a limit after which retries will no longer be attempted.


[[driver-service-unavailable]]
== Service unavailable

A Service unavailable status will be signalled when the driver is no longer able to establish communication with the server, even after retries.
Encountering this condition usually indicates a fundamental networking or database problem.
Applications should be designed to cater for this eventuality.

[.tabbed-example]
.Service unavailable
====
[.include-with-dotnet]
======

[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=service-unavailable]
----
======

[.include-with-go]
======
[source, go]
----
include::{go-examples}/examples_test.go[tags=service-unavailable]
----
======

[.include-with-java]
======

[source, java]
----
include::{java-examples}/ServiceUnavailableExample.java[tags=service-unavailable]
----
======

[.include-with-javascript]
======

[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=service-unavailable]
----
======

[.include-with-python]
======

[source, python]
----
include::{python-examples}/service_unavailable_example.py[tags=service-unavailable]
----
======
====
