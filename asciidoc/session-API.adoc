[[driver-session-API]]
= The Session API

[abstract]
--
This section details the Session API that are made available by the driver, with each Session class oriented towards a different form of programming.
--

[[driver-simple-sessions]]
== Simple sessions

[NOTE]
Available in .NET and Java

Simple sessions provide a "classic" blocking style API for Cypher execution and are available for most languages.
In general, simple sessions provide the easiest programming style to work with since API calls are executed in a strictly sequential fashion.

=== Lifecycle

Session lifetime extends from session construction to session closure.
In languages that support them, simple sessions are usually scoped within a context block; this ensures that they are properly closed and that any underlying connections are released and not leaked.

.Session construction and closure
[cols="2,2a"]
|===
| .NET
| [source, csharp]
using (var session = driver.Session(...)) {
    // transactions go here
}
| Java
| [source, java]
try (Session session = driver.session(...)) {
    // transactions go here
}
| JavaScript
| [source, javascript]
 // Not available as JavaScript does not
 // support blocking I/O
| Python
| [source, python]
with driver.session(...) as session:
    # transactions go here
|===

Sessions can be configured in a number of different ways.
This is carried out by supplying configuration inside the session constructor.
See 4.4. <<Session configuration>> for more details.

=== Transaction functions

Transaction functions are the recommended form for containing transactional units of work.
This form of transaction requires minimal boilerplate code and allows for a clear separation of database queries and application logic.
Transaction functions are also desirable since they encapsulate retry logic and allow for the greatest degree of flexibility when swapping out a single instance of server for a cluster.

Functions can be called as either read or write operations.
This choice will route the transaction to an appropriate server within a clustered environment.
If you are in a single instance environment, this routing has no impact but it does give you the flexibility should you choose to later adopt a clustered environment.

Before writing a transaction function it is important to ensure that any side-effects carried out by a transaction function should be designed to be idempotent.
This is because a function may be executed multiple times if initial runs fail.

Any query results obtained within a transaction function should be consumed within that function, as connection-bound resources cannot be managed correctly when out of scope.
To that end, transaction functions can return values but these should be derived values rather than raw results.

[NOTE]
When a transaction fails, the driver retry logic is invoked. For several failure cases, the transaction can be immediately retried against a different server.
These cases include connection issues, server role changes (e.g. leadership elections) and transient errors.
Retry logic can be configured when creating a session.

[.tabbed-example]
.Transaction function
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=transaction-function]
----
======

[.include-with-go]
======
[source, go]
----
include::{go-examples}/examples_test.go[tags=transaction-function]
----
======

[.include-with-java]
======
[source, java]
----
include::{java-examples}/TransactionFunctionExample.java[tags=transaction-function]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=transaction-function]
----
======

[.include-with-python]
======
[source, python]
----
include::{python-examples}/transaction_function_example.py[tags=transaction-function]
----
======
====


[[driver-result]]
== Statement results

A statement result is comprised of a stream of records.
The result is typically handled by the receiving application as it arrives, although it is also possible to retain all or part of a result for future consumption.

image::driver-result-stream.svg[title="Result stream", role="middle"]


[[driver-result-record]]
=== Records

A record provides an immutable view of part of a result.
It is an ordered map of keys and values.
As values within a record are both keyed and ordered, that value can be accessed either by position (0-based integer) or by key (string).


[[driver-result-buffer]]
=== The buffer

image::driver-result-buffer.svg[title="Result buffer", role="middle"]

Most drivers contain a result buffer.
This provides a staging point for results, and divides result handling into _fetching_ (moving from the network to the buffer) and _consuming_ (moving from the buffer to the application).

If results are consumed in the same order as they are produced, records merely pass through the buffer; if they are consumed out of order, the buffer will be utilized to retain records until they are consumed by the application.
For large results, this may require a significant amount of memory and impact performance. For this reason, it is recommended to consume results in order wherever possible.


[[driver-result-consume]]
=== Consuming the stream

Query results will often be consumed as a stream.
Drivers provide a language-idiomatic way to iterate through a result stream.

[.tabbed-example]
.Consuming the stream
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=result-consume]
----
======

[.include-with-go]
======
[source, go]
----
include::{go-examples}/examples_test.go[tags=result-consume]
----
======

[.include-with-java]
======
[source, java]
----
include::{java-examples}/ResultConsumeExample.java[tags=result-consume]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=result-consume]
----
======

[.include-with-python]
======
[source, python]
----
include::{python-examples}/result_consume_example.py[tags=result-consume]
----
======
====


[[driver-result-retain]]
=== Retaining results

The result record stream is available until another statement is run in the session, or until the current transaction is closed.
To hold on to the results beyond this scope, the results need to be explicitly retained.
For retaining results, each driver offers methods that collect the result stream and translate it into standard data structures for that language.
Retained results can be processed while the session is free to take on the next workload.
The saved results can also be used directly to run a new statement.



[.tabbed-example]
.Retain results for further processing
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=result-retain]
----
======
[.include-with-go]
======
[source, go]
----
include::{go-examples}/examples_test.go[tags=result-retain]
----
======
[.include-with-java]
======
[source, java]
----
include::{java-examples}/ResultRetainExample.java[tags=result-retain]
----
======
[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=result-retain]
----
======
[.include-with-python]
======
[source, python]
----
include::{python-examples}/result_retain_example.py[tags=result-retain]
----
======
====


[[driver-result-summary]]
== Statement result summaries

Supplementary information such as query statistics, timings and server information can be obtained from the statement result summary.
If this detail is accessed before the entire result has been consumed, the remainder of the result will be buffered.

See also the <<driver-api-docs, language-specific driver API documentation>>.
