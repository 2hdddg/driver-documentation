[[driver-run-statements]]
= Run statements

[abstract]
--
All interactions with a Neo4j database take place within a session.
Each session is the context for one or more transactions of work against the database.
--

A session is a lightweight container for a sequence of transactions.
The session is obtained from the driver object.
It provides the context of work for individual transactions.

When using a routing driver, declare the session access mode as `READ` or `WRITE`.
The driver will create a session against a suitable cluster member for the selected mode of work.

In the ordinary case, transactions are explicitly managed.
This means that a transaction is created from a session and used to run one or more statements.
For each statement, results may be processed and any exceptions handled.
When the sequence of transactions have all been executed, the session is closed.

// To run a statement, use the session to create a transaction.
// Call the `run()` method on the transaction object and pass in the query and parameters.

[.tabbed-example]
.Run a statement
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=transaction-commit]
----
======

[.include-with-java]
======
[source, java]
----
include::{java-examples}/Examples.java[tags=transaction-commit]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=transaction-commit]
----
======

[.include-with-python]
======
[source, python]
----
include::{python-examples}/test_examples.py[tags=transaction-commit]
----
======
====


== Sessions

A session is a wrapper around a connection that can be used to group units of work with a common end point.
To acquire a new session, use the `driver.session` method.
Session creation is a cheap process.
The underlying connection will be borrowed from the driver connection pool on construction and returned to the pool on closure.

Sessions are not thread-safe.


=== Access mode

When the driver has routing enabled, provide the desired access mode: `READ` or `WRITE`.
If omitted, `WRITE` is assumed for backward compatibility.

The routing driver will create the session against an endpoint which is suitable for writing or reading, respectively.
Deploying against a Causal Cluster means that the driver can route reads and writes efficiently.
Reads are directed to the Read replicas, while writes go to the Core of the cluster for consensus commit and safekeeping.

If the instance against which a session is created is no longer available for the declared access mode, the application will receive a `SessionExpiredException`.
When this occurs, the application should acquire another session from the driver and replay the failing transaction.


=== Connection pooling

// TODO: Suggest already here how closing a session relates to consuming results and to exceptions.

The driver has a connection pool and a session will borrow a connection to carry out its work.
When the session is closed, the connection is returned to the pool.
It is important to ensure that sessions are closed properly so that results and errors are fully received by the client and so that connections can be reused.

[CAUTION]
--
It is important to provide for the closing of a session in the case where an exception is thrown.
Ensure that the exceptional path of execution, as well as the expected one, closes the session.
--


== Roll back a transaction

The transaction can also be rolled back.

[.tabbed-example]
.Roll back a transaction
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=transaction-rollback]
----
======

[.include-with-java]
======
[source, java]
----
include::{java-examples}/Examples.java[tags=transaction-rollback]
----
======
[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=transaction-rollback]
----
======
[.include-with-python]
======
[source, python]
----
include::{python-examples}/test_examples.py[tags=transaction-rollback]
----
======
====


== Auto-commit transactions

While the ordinary case is to use explicit transactions, it is also possible to run statements directly from a session.
The session's `run()` method implicitly begins and commits a transaction in which the statement is run.
This is a convenience method for individual read-only queries.

Auto-commit transactions do not support bookmarking and are difficult to diagnose on failure when pipelined.
// TODO: Charlie what now?
//       We haven't told the user what "pipelining" is.

// When the session runs a statement directly, it creates an implicit transaction.
// The session can also create explicit transactions to be managed manually.
// When explicitly told to begin a new transaction, the session will return a transaction object.
// The transaction object allows for fine-grained transaction control.

[.tabbed-example]
.Run a statement in an auto-commit transaction
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=statement]
----
======

[.include-with-java]
======
[source, java]
----
include::{java-examples}/Examples.java[tags=statement]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=statement]
----
======

[.include-with-python]
======
[source, python]
----
include::{python-examples}/test_examples.py[tags=statement]
----
======
====


== Query parameters

It is recommended always to use parameters.
Using parameters has significant performance and security benefits:

* It allows the query planner to reuse its plans, making queries much more efficient.
* It protects the database from Cypher injection attacks, where malicious query clauses are added from poorly typed or filtered input.

It is possible, however, to run a query with literal values.

[.tabbed-example]
.Run a statement without parameters
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=statement-without-parameters]
----
======

[.include-with-java]
======
[source, java]
----
include::{java-examples}/Examples.java[tags=statement-without-parameters]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=statement-without-parameters]
----
======

[.include-with-python]
======
[source, python]
----
include::{python-examples}/test_examples.py[tags=statement-without-parameters]
----
======
====


include::bookmarking.adoc[leveloffset=+1]

