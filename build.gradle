import org.ajoberstar.grgit.*
import org.asciidoctor.groovydsl.AsciidoctorExtensions
import org.asciidoctor.Asciidoctor
import org.asciidoctor.OptionsBuilder
import org.neo4j.doc.build.xslt.XsltTask
import org.neo4j.doc.build.docbook.DocBookPlugin

buildscript {
    ext {
        asciidoctorjVersion = '1.5.6'
        asciidoctorjPdfVersion = '1.5.0-alpha.16'
        asciidoctorGroovyDslVersion = '1.0.0.Alpha2'
        gradleGitVersion = '1.4.2'
        catalogDir = "$projectDir/docbook/catalog"
    }

    repositories {
        jcenter()
    }

    dependencies {
        classpath "org.asciidoctor:asciidoctorj:$asciidoctorjVersion"
        classpath "org.asciidoctor:asciidoctorj-pdf:$asciidoctorjPdfVersion"
        classpath "org.asciidoctor:asciidoctorj-groovy-dsl:$asciidoctorGroovyDslVersion"
        classpath "org.ajoberstar:gradle-git:$gradleGitVersion"
        classpath 'net.sf.docbook:docbook-xsl:1.79.1:ns-resources@zip'
        classpath fileTree(dir: "${rootProject.projectDir}/lib", include: '*.jar')
        classpath files(catalogDir)
    }
}

plugins {
    id 'base'
    id 'de.undercouch.download' version '3.2.0'
    id 'org.neo4j.doc.build.vale' version '1.0-alpha01'
    id 'org.neo4j.doc.build.saxon' version '1.0-alpha01'
    id 'org.neo4j.doc.build.docbook' version '1.0-alpha04'
}

version '1.6'

def traceDocbook = hasProperty('traceDocbook') ? true : false
if (!project.hasProperty("neo4jVersion")) { ext.neo4jVersion = "3.2.0-SNAPSHOT" }
if (!project.hasProperty("driverVersion")) { ext.driverVersion = "1.6" }
if (!project.hasProperty("ogmVersion")) { ext.ogmVersion = "2.1.2" }

ext {
    // Set `neo4jDocVersion` for use in the generated docs
    // Those docs that follow Neo4j versions do so tracking `major.minor[-prerelease]`
    // So, drop the patch version:
    neo4jVersionParts = neo4jVersion.split('-')
    neo4jDocVersion = neo4jVersionParts[0][0..2]
    if (1 < neo4jVersionParts.size()) {
        neo4jDocVersion += "-alpha"
    }

    // Make it a little easier to build release and pre-release OGM docs.
    ogmDocVersion = ogmVersion.tokenize('.')[0..1].join(".")
    if (ogmVersion.contains("-")) {ogmDocVersion += "-pre"}

    driverVersionMapUrl = 'https://s3-eu-west-1.amazonaws.com/drivers.neo4j.com/version-tracker/version.json'
    getDriverVersionMap = {
        if (!project.hasProperty('driverVersionMap')) {
            def versionsFile = "$buildDir/driverVersions.json"
            download {
                src driverVersionMapUrl
                dest versionsFile
                onlyIfNewer true
                overwrite true
            }
            ext.driverVersionMap = new groovy.json.JsonSlurper().parseText(file(versionsFile).text)
        } else {
            ext.driverVersionMap
        }
    }

    // Driver version can be overridden: `-PdriverVersion=`
    if (!project.hasProperty('driverVersion')) {
        ext.driverVersion = getDriverVersionMap().serverSeries[neo4jSeries].recommendedDriverSeries
    }

    // Driver API doc versions can be overridden: `-PdotnetDriverApiDocVersion=`
    // Default to `driverVersion`
    ["dotnetDriverApiDocVersion", "javaDriverApiDocVersion", "javascriptDriverApiDocVersion", "pythonDriverApiDocVersion"].each {
        if (!project.hasProperty(it)) { ext."$it" = driverVersion }
    }

    driverLanguages = [
            'dotnet': [
                    'name'   : 'C#',
                    'version': getDriverVersionMap().driverLanguages.dotnet.driverSeries[driverVersion],
                    'gitref' : getDriverVersionMap().driverLanguages.dotnet.driverSeries[driverVersion],
                    'url'    : 'https://www.nuget.org/packages/Neo4j.Driver'
            ],
            'java': [
                    'name'   : 'Java',
                    'version': getDriverVersionMap().driverLanguages.java.driverSeries[driverVersion],
                    'gitref' : getDriverVersionMap().driverLanguages.java.driverSeries[driverVersion],
                    'url'    : 'http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.neo4j.driver%22%20AND%20a%3A%22neo4j-java-driver%22'
            ],
            'javascript': [
                    'name'   : 'JavaScript',
                    'version': getDriverVersionMap().driverLanguages.javascript.driverSeries[driverVersion],
                    'gitref' : getDriverVersionMap().driverLanguages.javascript.driverSeries[driverVersion],
                    'url'    : 'https://www.npmjs.com/package/neo4j-driver'
            ],
            'python'    : [
                    'name'   : 'Python',
                    'version': getDriverVersionMap().driverLanguages.python.driverSeries[driverVersion],
                    'gitref' : getDriverVersionMap().driverLanguages.python.driverSeries[driverVersion],
                    'url'    : 'https://pypi.python.org/pypi/neo4j-driver'
            ]
    ]
    driverLanguages.each { lang, info ->
        println "$lang driver version: $info.version"
    }
    driverDocVersion = driverVersion

    versions = [
        'driverDocs'    : version,
        'neo4jDocs'     : neo4jDocVersion,
        'ogmDocs'       : ogmDocVersion,
        'kerberosAddOn' : '1.0',
    ]


    copyrightYear = '2018'
    docsBaseUri = "https://neo4j.com/docs"
    crossReferenceBase = [ // We have no strategy for cross references yet; always link to current.
            'cypher-manual'     : "${docsBaseUri}/cypher-manual/current",
            'driver-manual'     : "${docsBaseUri}/driver-manual/current",
            'operations-manual' : "${docsBaseUri}/operations-manual/current",
            'java-reference'    : "${docsBaseUri}/java-reference/current",
            'rest-docs'         : "${docsBaseUri}/rest-docs/current",
            'ogm-manual'        : "${docsBaseUri}/ogm-manual/current",
            'kerberos-add-on'   : "${docsBaseUri}/add-on/kerberos/current"
    ]
    asciidoctorAttributes = [
        'common': [
            'copyright-year'                   : copyrightYear,
            'copyright'                        : "${copyrightYear} Neo Technology",
            'common-license-page-uri'          : "${docsBaseUri}/license",
            'driver-version'                   : driverVersion,
            'doctype'                          : 'book',
            'icons'                            : 'font',
            'attribute-missing'                : 'warn',
            'docs-version'                     : versions.driverDocs,
            'common-license-page-uri'          : "$docsBaseUri/license/",
            'dotnet-driver-apidoc-version'     : dotnetDriverApiDocVersion,
            'java-driver-apidoc-version'       : javaDriverApiDocVersion,
            'javascript-driver-apidoc-version' : javascriptDriverApiDocVersion,
            'python-driver-apidoc-version'     : pythonDriverApiDocVersion,
            'kerberos-add-on-base-uri'          : crossReferenceBase['kerberos-add-on'],
        ],
        'docbook': [
            'imagesdir'          : 'images',
        ],
        'html': [
            'stylesdir'          : 'css',
            'linkcss'            : '',
            'imagesdir'          : 'images',
        ],
        'pdf': [
            'source-highlighter': 'rouge',
            'toc'               : '',
            'showlinks'         : '',
            'nonhtmloutput'     : '',
            // 'pdf-fontsdir'      : "$rootProject.buildDir/fonts".toString(),
        ]
    ]
    asciidocSourceDir = "$projectDir/asciidoc"
    distDir = "$buildDir/distributions"
    docId = 'driver-manual'
    fonts = [
            'Open Sans.zip'  : 'https://www.google.com/fonts/download?kit=3hvsV99qyKCBS55e5pvb3ltkqrIMaAZWyLYEoB48lSQ',
            'Inconsolata.zip': 'https://www.google.com/fonts/download?kit=CNj0Ze1H6w4FVgc32wmZS4fD-WQWLbF4rYwcBGowFYY',
            'Lora.zip'       : 'https://www.google.com/fonts/download?kit=iwrHM7FQEcKgsUvDuXxrPg',
    ]

}

// defaultTasks 'asciidoctorHtml', 'asciidoctorPdf'

ext {
    adoc = null

    // a wrapper closure around executing a string
    // can take either a string or a list of strings (for arguments with spaces)
    runCommand = { strList ->
        assert ( strList instanceof String ||
            ( strList instanceof List && strList.each{ it instanceof String } ) \
    )
        def proc = strList.execute()
        // proc.in.eachLine { line -> println line }
        proc.out.close()
        proc.waitFor()
        // print "[INFO] ( "
        // if(strList instanceof List) {
        //     strList.each { print "${it} " }
        // } else {
        //     print strList
        // }
        // println " )"
        if (proc.exitValue()) {
            println "gave the following error: "
            println "[ERROR] ${proc.getErrorStream()}"
        }
        assert !proc.exitValue()
    }

}

project.ext.driverLanguages.each { lang, info ->
    project.ext.asciidoctorAttributes.common["$lang-driver-version"] = info['version']
    project.ext.asciidoctorAttributes.common["$lang-root"] = targetGitdir(lang, info['gitref'])
    project.ext.asciidoctorAttributes.html["include-with-$lang"] = ''
    project.ext.asciidoctorAttributes.docbook["include-with-$lang"] = ''

    task ("${lang}DriverApiDocs", type: Tar) {
        description "Package API docs for the ${lang} driver."
        baseName "${lang}-driver"
        version driverVersion
        extension "tar.gz"
        compression Compression.GZIP
        from {
            file("${projectDir}/shared/${lang}-driver-api-docs").exists() ? "${projectDir}/shared/${lang}-driver-api-docs" : "apidocs/${lang}"
        }
        into {
            "api/${baseName}/${driverVersion}"
        }
        destinationDir file("${buildDir}/distributions")
    }
    task ("${lang}DriverSources") {
        description "Clones the ${lang} driver sources from GitHub or uses local checkouts."
        def targetDir = targetGitdir(lang, info['gitref'])
        outputs.dir targetDir
        onlyIf { !file(targetDir).exists() }
        doLast {
            println "Cloning neo4j-$lang-driver repository."
            Grgit.clone(dir: targetDir,
                        uri: "https://github.com/neo4j/neo4j-$lang-driver.git",
                        refToCheckout: info['gitref'])

        }
    }
}

def targetGitdir(lang, gitref) {
    if (project.hasProperty('localDriverSources')) {
        file("$projectDir/../neo4j-$lang-driver")
    } else {
        file("${rootProject.buildDir}/driver-sources/${lang}-driver/${gitref}")
    }
}

def deps = driverLanguages.collect {"${it.getKey()}DriverApiDocs"}
task driverApiDocsPackage(dependsOn: deps) {
    description 'Package the driver API docs.'
}

def driverSourcesTasks = driverLanguages.collect {"${it.getKey()}DriverSources"}
task prepareDriverSources(dependsOn: driverSourcesTasks){
    description "Prepare driver sources."
}

def getAsciidoctor(withTabbedExampleProcessor) {
    project.ext.adoc = Asciidoctor.Factory.create()
    if (withTabbedExampleProcessor) {
        adoc.rubyExtensionRegistry()
            .loadClass(new FileInputStream(file("${rootProject.projectDir}/extensions/tabbed_example_processor.rb")))
            .treeprocessor("TabbedExampleProcessor")
    }
    project.ext.adoc
}

task docbook(dependsOn: prepareDriverSources) {
    description 'Build DocBook.'
    ext.sourceDir = asciidocSourceDir
    ext.sourceFile = file("$sourceDir/index.adoc")
    ext.outputDir = "$buildDir/docbook/${versions.driverDocs}"
    inputs.dir sourceDir
    outputs.dir outputDir
    def templateDir = "${rootProject.projectDir}/templates/docbook"
    doLast {
        def attrs = asciidoctorAttributes.common + asciidoctorAttributes.docbook + [
                    'driver-manual-version'  : versions.driverDocs,
                    'project-root'           : "${rootProject.projectDir}",
        ]
        def opts = org.asciidoctor.OptionsBuilder.options()
                .backend('docbook5')
                .safe(org.asciidoctor.SafeMode.UNSAFE)
                .toDir(file(outputDir))
                .templateDir(new File(templateDir))
                .mkDirs(true)
                .attributes(attrs)
        getAsciidoctor(true).convertFile(sourceFile, opts.get())
    }
    doLast {
        copy {
            from("$projectDir/asciidoc") {
                include 'images/**'
            }
            into outputDir
        }
    }
    finalizedBy 'preprocess'
}

preprocess {
    dependsOn docbook
    def sourceFile = "${docbook.outputDir}/index.xml"
    input sourceFile
    outFile sourceFile
    parameters([
        "book-id": "$docId"
    ])
    doFirst {
        def cmd = ["${projectDir}/bin/post-process.sh", sourceFile, "${projectDir}/bin/post-process.sed"]
        runCommand(cmd)
    }
}

task makeToc(type: XsltTask, dependsOn: docbook) {
    description 'Create a table of contents aka complete content map.'
    ext.sourceDir = docbook.outputDir
    ext.sourceFile = "$sourceDir/index.xml"
    ext.outputFile = "$buildDir/docbook/${versions.driverDocs}/toc.xml"
    def outputDir = "$buildDir/docbook/${versions.driverDocs}/_trash"

    def url = DocBookPlugin.getClassLoader().getResource("xsl/create-toc/xhtml/maketoc.xsl")
    stylesheet url
    input sourceFile
    outFile outputFile

    sourceSaxParser "org.apache.xml.resolver.tools.ResolvingXMLReader"
    stylesheetSaxParser "org.apache.xml.resolver.tools.ResolvingXMLReader"
    uriResolver "org.apache.xml.resolver.tools.CatalogResolver"

    usingUrls true
    usingClasspathUrls true
    if (hasProperty('traceDocbook')) { verbose true }

    parameters([
        "base.dir": "${outputDir}",
        "chunk.section.depth": "8",
        "chunk.first.sections": "1",
        "use.id.as.dirname": "1",
    ])
}

html {
    dependsOn docbook
    ext.sourceDir = docbook.outputDir
    ext.sourceFile = "$sourceDir/index.xml"
    ext.outputDir = "$buildDir/html/${versions.driverDocs}"
    ext.contentMap = "$projectDir/docbook/content-map.xml"
    inputs.file sourceFile
    inputs.dir 'css'
    inputs.dir 'images'
    inputs.dir 'javascript'
    outputs.dir outputDir

    def libraryLinks = [
        "Operations_Manual=${crossReferenceBase['operations-manual']}/",
        "Cypher_Manual=${crossReferenceBase['cypher-manual']}/",
        "Driver_Manual=${crossReferenceBase['driver-manual']}/",
        "OGM_Manual=${crossReferenceBase['ogm-manual']}/",
        "Graph_Algorithms=${crossReferenceBase['graph-algorithms']}/",
        "Java_Reference=${crossReferenceBase['java-reference']}/",
    ].join(" ")
    def scripts = [
        '//ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js',
        '//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js',
        '//cdnjs.cloudflare.com/ajax/libs/codemirror/5.11.0/codemirror.min.js',
        '//cdnjs.cloudflare.com/ajax/libs/codemirror/5.11.0/addon/runmode/runmode.min.js',
        '//cdnjs.cloudflare.com/ajax/libs/codemirror/5.11.0/mode/cypher/cypher.min.js',
        'javascript/colorize.js',
        'javascript/tabs-for-chunked.js',
        'javascript/mp-nav.js',
        'javascript/versionswitcher.js',
        'javascript/version.js',
        '//s3-eu-west-1.amazonaws.com/alpha.neohq.net/docs/new-manual/assets/search.js',
    ].join(" ")
    def styles = [
        '//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css',
        '//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.1.0/css/font-awesome.min.css',
        '//fonts.googleapis.com/css?family=Open+Sans:400,300,400italic,600,300italic',
        '//cdnjs.cloudflare.com/ajax/libs/codemirror/5.11.0/codemirror.min.css',
        '//cdnjs.cloudflare.com/ajax/libs/codemirror/5.11.0/theme/neo.min.css',
        'css/chunked-base.css',
        'css/extra.css'
    ].join(" ")

    stylesheet "classpath:xsl/chunk-from-toc/xhtml/chunktoc.xsl"
    input sourceFile

    // Stylesheet parameters
    parameters ([
        "base.dir": "${outputDir}",
        "html.ext": ".html",
        "make.clean.html": "1",
        "chunker.output.method": "html",
        "chunker.output.indent": "yes",
        "use.id.as.dirname": "1",
        "neo.documentation.library.links": libraryLinks,
        "generate.toc": "''",
        "header.rule": "0",
        "neo.newsearch": "1",
        "html.script": scripts,
        "html.stylesheet": styles,
        "chunk.toc": "${contentMap}",
        "current.docid": "$docId",
    ])
    doLast {
        copy {
            from(docbook.outputDir) {
                include 'images/**'
            }
            from(projectDir) {
                include 'javascript/**'
                include 'css/**'
            }
            into outputDir
        }
    }
}


task packageHtml(type: Tar, dependsOn: html) {
    description 'Package HTML for distribution.'
    baseName 'driver-manual'
    extension 'tar.gz'
    version versions.driverDocs
    compression = Compression.GZIP
    from { html }
    into "$baseName/$version"
    destinationDir file(distDir)
}

task pdf(dependsOn: prepareDriverSources) {
    description 'Build PDF.'
    ext.sourceDir = asciidocSourceDir
    ext.sourceFile = file("$sourceDir/index.adoc")
    ext.outputDir = "$buildDir/pdf/"
    ext.outputFilename = "neo4j-driver-manual-${versions.driverDocs}.pdf"
    ext.imagesDir = "images"
    inputs.dir sourceDir
    // outputs.dir outputDir
    doLast {
        project.ext.driverLanguages.each { lang, info ->
            println "[+] Driver Manual PDF for ${lang}"
            def attrs = asciidoctorAttributes.common + asciidoctorAttributes.pdf + [
                    ('include-with-' + lang) : true,
                    'driver-manual-version'  : versions.driverDocs,
                    'project-root'           : "${rootProject.projectDir}",
                    'imagesdir'              : imagesDir.toString(),
            ]
            def opts = org.asciidoctor.OptionsBuilder.options()
                    .backend('pdf')
                    .safe(org.asciidoctor.SafeMode.UNSAFE)
                    .toFile(file("$outputDir/neo4j-driver-manual-${versions.driverDocs}-${lang}.pdf"))
                    .mkDirs(true)
                    .attributes(attrs)
            getAsciidoctor(true).convertFile(sourceFile, opts.get())
        }
    }
}

task packagePdf(type: Copy, dependsOn: pdf) {
    from (pdf.outputDir) {
        include '*.pdf'
    }
    into "$distDir/pdf"
}

task dist(dependsOn: [packageHtml, pdf]) {
    description 'Build and package HTML and PDF outputs.'
    doLast {

    }
}

// vim: set fdm=expr:
